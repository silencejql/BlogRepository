---
title: C# Static
permalink: C# Static
comments: true
copyright: false
abstract: 交钱！
message: Enter password to read！
date: 2019-07-05 10:59:00
description:
categories:
- C#
tags:
- static
top:
password:
---
静态方法只能访问类的静态成员，不能访问类的非静态成员；
非静态方法可以访问类的静态成员，也可以访问类的非静态成员；
静态方法不能使用实例来调用，只能使用类名来调用。
<!--more-->
#### static
##### 静态全局变量
>特点：
>>1、该变量在全局数据区分配内存。
>>2、初始化：如果不显式初始化，那么将被隐式初始化为0。

##### 静态局部变量
>特点：
>>1、该变量在全局数据区分配内存。
>>2、初始化：如果不显式初始化，那么将被隐式初始化为0。
>>3、**它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。**

##### 静态数据成员

>内存分配：在程序的全局数据区分配。
>初始化和定义：
>>1、静态数据成员定义时要分配空间，所以不能在类声明中定义。
>>2、为了避免在多个使用该类的源文件中，对其重复定义，所以，不能在类的头文件中定义。
>>3、静态数据成员因为程序一开始运行就必需存在，所以其初始化的最佳位置在类的内部实现。

>特点
>>对相于 public,protected,private 关键字的影响它和普通数据成员一样，因为其空间在全局数据区分配，属于所有本类的对象共享，所以，它不属于特定的类对象，在没产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它。

>访问形式
>>类对象名.静态数据成员名

静态数据成员，主要用在类的所有实例都拥有的属性上。比如，对于一个存款类，帐号相对于每个实例都是不同的，但每个实例的利息是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处，第一，不管定义多少个存款类对象，利息数据成员都共享分配在全局区的内存，所以节省存贮空间。第二，一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了，因为它们实际上是共用一个东西。

##### 静态成员函数
>特点：
>>1、静态成员函数与类相联系，不与类的对象相联系。
>>2、静态成员函数不能访问非静态数据成员。原因很简单，非静态数据成员属于特定的类实例。

>作用：
>>主要用于对静态数据成员的操作。

>调用形式：
>>类对象名.静态成员函数名（）

##### 总结
静态方法只能访问类的静态成员，不能访问类的非静态成员；
非静态方法可以访问类的静态成员，也可以访问类的非静态成员；
静态方法不能使用实例来调用，只能使用类名来调用。

```csharp
static int i = getNum();
int j = getNum();
static int num = 1;
static int getNum()
{
    return num;
}
static void Main(string[] args)
{
    Console.WriteLine("i={0}",i);
    Console.WriteLine("j={0}", new class1().j);
    Console.Read();
}
```
分析：`Console.WriteLine("i={0}",i);`这里`i`是`static`变量，而且类`class1`是第一次被引用，要先为`class1`里面所有的`static`变量分配内存。尽管现在有超线程技术，但是指令在逻辑还是一条一条的按顺序执行的，所以先为`static int i`分配内存，并且在该内存中保持`int`的缺省值`0`，接着再为`static` `int num` 变量分配内存，值当然也为`0`。

然后执行第二步，为变量赋值：先为`static int i`变量赋值，`i＝getNum()`，看getNum里面的代码，就是`return num`，这个时候`num`的值是`0`，于是`i`就为`0`了。然后对变量`num`赋值，`num＝1；`这行代码执行后，`num`就为`1`了。
##### static的优点是什么？为什么要使用static 变量或函数？？
有一些频繁使用的东西，如果你每次使用都重新`new`一下，那么这个开销可能会很高，如果使用`static`，一直放在内存中，那么想用就直接用，而不需要重新`new`一块空间初始化数据。那么`static`就是为了实现一个系统的缓存作用的，其生命周期直到应用程序退出结束。

静态成员包括静态字段和静态属性，静态成员和类相关联，不依赖于对象而存在，只能由类访问，而不能由对象访问；

静态成员属于类所有，无认创建多少实例对象，静态成员在内存中只有一份；实例成员属于类的实例所有，每创建一个实例对象，实例成员都会在内存中分配一块内存区域。
所以静态成员一般用于存放共享的数据段，如数据库连接字符串等。

一个类如果只包含静态成员和静态方法，则该类可以定义为静态类，给类加上`static`修饰符；

##### 静态方法和非静态方法：
一、性能上：静态方法和实例方法差别不大。所有方法，不管是静态方法还是实例方法，都是在JIT加载类时分配内存，不同的是静态方法以类名引用，而实例方法对对象实例引用。创建实例时，不会再为类的方法分配内存，所有的实例对象共用一个类的方法代码。因此静态方法和实例方法的调用，在性能上的差别微乎其微。

二、静态方法只能由类访问；实例方法只能由对象访问。

>优点：
>>1、静态变量在类载入时，就装入内存
>>2、使用时不用 New 就意味的不必 创建类中 所有对象，就可以调用 某个方法

>缺点：
>>垃圾回收机制 不能 回收 静态变量，静态类变量 会常驻内存

##### c#中静态类的优缺点
>缺点：
>>1、整个类型在程序运行期间只加载一次。 这样是对于那些经常使用的类型来说的，那就不用每次使用前都先加载。效率高些。但是对那些不常用的类型来说。
2、如果是静态类型，那就要一直占用相当的内存；一直到程序停止。或者应用程序域被卸载。所以应该只对那些常用的类型定义成静态类型。

>优点：
>>1、它们仅包含静态成员。
2、它们不能被实例化。
3、它们是密封的。
4、它们不能包含实例构造函数（C# 编程指南）。
